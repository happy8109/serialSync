---
alwaysApply: true
---

# SerialBridge 重构工作指导规则

## 🎯 重构目标
将现有的1287行 `SerialManager.js` 重构为模块化的 `SerialBridge` 架构，彻底重写核心协议，设计统一、简洁、通用的数据传输协议。

## 🏗️ 核心设计原则

### 1. 统一协议设计
- **协议格式**：`[0xAA][TYPE][REQ_ID][LEN_H][LEN_L][DATA][CHECKSUM]`
- **无长度限制**：支持最大65535字节的单包传输
- **类型清晰**：通过TYPE字段明确区分数据类型
- **二进制安全**：支持任意二进制数据，包括换行符等特殊字符
- **统一处理**：所有数据使用相同的封包/解包逻辑

### 2. 分层架构设计
```
应用层 (业务逻辑) → 统一传输层 (SerialBridge) → 核心层 (协议处理) → 基础层 (基础服务)
```
- **职责分离**：每层职责清晰，边界清楚
- **调度器透明**：应用层调用`serialBridge.sendData()`，调度器自动工作
- **模块化**：每个模块控制在200-400行

### 3. 功能对等保证
- **功能一致性优先**：最终功能与重构前保持一致，而非API兼容性
- **服务重写**：上层服务可以完全重写，利用新核心的优势
- **独立测试**：核心功能独立测试，不依赖上层应用

## 📅 实施阶段指导

### 阶段一：现状调研与保护 (0.5天)
**必须完成**：
- [ ] 设置 `SerialManager.js` 为只读状态
- [ ] 创建 `SerialManager.js.backup` 备份文件
- [ ] 详细分析现有API接口和功能
- [ ] 分析现有配置结构和事件系统

**验收标准**：现有代码完全保护，现有功能完全理解

### 阶段二：统一协议设计 (1-2天)
**核心任务**：
- [ ] 实现 `ProtocolUtils` 统一协议工具
- [ ] 实现 `UnifiedProtocol` 统一协议处理器
- [ ] 支持任意字符传输（包括换行符）
- [ ] 编写协议兼容性测试用例

**验收标准**：统一协议格式确定，封包/解包逻辑正确

### 阶段三：传输调度器设计 (1-2天)
**核心任务**：
- [ ] 实现 `TransmissionScheduler` 内部调度器
- [ ] 设计服务注册和优先级机制
- [ ] 实现基本的调度逻辑
- [ ] 实现与核心层的接口对接

**验收标准**：调度器架构设计完成，基本调度功能实现

### 阶段四：基础架构搭建 (1-2天)
**核心任务**：
- [ ] 实现 `ConfigManager` 配置管理
- [ ] 实现 `ConnectionManager` 连接管理
- [ ] 实现 `SerialBridge` 统一传输层
- [ ] 创建适配器模式，保持现有功能可用

**验收标准**：新模块与现有模块并行存在，基础功能正常

### 阶段五：统一协议集成 (2-3天)
**核心任务**：
- [ ] 集成 `UnifiedProtocol` 到 `SerialBridge`
- [ ] 实现文本数据传输（支持换行符）
- [ ] 实现文件数据传输
- [ ] 实现配置热重载

**验收标准**：文本和文件传输正常，统一协议解析正确

### 阶段六：CLI服务重写 (1-2天)
**核心任务**：
- [ ] 重写 `FileTransferService` 文件传输服务
- [ ] 重新实现大数据自动处理
- [ ] 重新实现详细进度跟踪
- [ ] 重写CLI命令和交互逻辑

**验收标准**：CLI服务功能与重构前完全对等

## 🔧 技术实现指导

### 1. SerialBridge 统一传输层
```javascript
class SerialBridge extends EventEmitter {
  // 统一传输接口 (集成调度器，对应用层透明)
  async sendData(type, data, reqId, options)
  
  // 连接管理
  async connect(portOverride)
  async disconnect(isManual)
  getConnectionStatus()
  
  // 配置热重载
  async reloadConfig()
  updateConfig(newConfig)
}
```

**设计特点**：
- 集成调度器功能，自动管理所有传输任务
- 对应用层完全透明，无需显式调用调度器
- 提供与现有 `SerialManager` 完全相同的API

### 2. TransmissionScheduler 内部调度器
```javascript
class TransmissionScheduler {
  // 内部调度接口 (SerialBridge内部调用)
  async scheduleTransmission(task)
  
  // 队列管理
  enqueueTask(task)
  pauseTask(taskId)
  resumeTask(taskId)
  removeTask(taskId)
  clearQueue()
  
  // 队列状态
  getQueueStatus()
  getTaskStatus(taskId)
  getQueueStatistics()
}
```

**设计理念**：
- SerialBridge内部使用，应用层完全不可见
- 统一队列管理，智能调度
- 支持任务的暂停、恢复、剔除等操作

### 3. UnifiedProtocol 统一协议处理
```javascript
class UnifiedProtocol {
  // 统一封包/解包
  packData(type, reqId, data)
  unpackData(packet)
  
  // 数据类型处理 (支持任意字符)
  handleTextData(data)        // 支持换行符等特殊字符
  handleFileData(data)
  handleApiRequest(data)
  handleApiResponse(data)
  handleControlCommand(data)
  handleProgressData(data)    // 进度信息
  
  // 工具函数
  calculateChecksum(data)
  compressData(data)
  decompressData(data)
  isBinarySafe(data)
}
```

## 🛡️ 风险控制规则

### 1. 代码保护
- **必须设置**：`SerialManager.js` 为只读状态
- **必须创建**：备份文件 `SerialManager.js.backup`
- **禁止修改**：现有文件，只能作为参考

### 2. 功能对等验证
- **每个阶段**：必须通过功能对等测试
- **测试覆盖**：功能对等测试、回归测试、性能测试
- **验证标准**：相同输入产生相同功能结果

### 3. 渐进式替换
- **并行开发**：新模块与现有模块并行存在
- **配置开关**：控制使用新旧实现
- **逐步切换**：先切换非关键功能，再切换核心功能

## 📊 质量保证规则

### 1. 代码质量
- **模块大小**：每个核心模块控制在200-400行
- **职责单一**：每个模块只负责一个明确的功能
- **接口清晰**：提供简洁明确的API接口

### 2. 测试要求
- **单元测试**：每个模块必须有完整的单元测试
- **集成测试**：模块间协作必须有集成测试
- **性能测试**：确保不降低现有性能水平

### 3. 文档同步
- **代码注释**：关键逻辑必须有详细注释
- **API文档**：所有公共接口必须有文档
- **架构文档**：及时更新架构设计文档

## 🚫 禁止事项

### 1. 架构破坏
- **禁止**：在核心层实现业务逻辑
- **禁止**：应用层直接调用调度器
- **禁止**：破坏分层架构的边界

### 2. 兼容性破坏
- **禁止**：修改现有事件名称和参数
- **禁止**：破坏现有API接口
- **禁止**：降低现有功能性能

### 3. 代码质量
- **禁止**：创建超过400行的模块
- **禁止**：在核心层添加业务逻辑
- **禁止**：忽略错误处理和边界情况

## ✅ 成功标准

### 1. 功能标准
- [ ] 所有现有功能与重构前完全对等
- [ ] 新架构模块职责清晰
- [ ] 代码行数合理分布（每个模块<400行）
- [ ] 功能对等测试覆盖率达到80%以上

### 2. 性能标准
- [ ] 连接建立时间不超过现有水平
- [ ] 数据传输速度不低于现有水平
- [ ] 内存使用不超过现有水平
- [ ] CPU使用率不超过现有水平

### 3. 维护性标准
- [ ] 新功能开发效率提升50%
- [ ] 代码定位时间减少70%
- [ ] 单元测试编写时间减少60%
- [ ] 文档维护工作量减少40%

## 🎯 下一步行动

### 立即开始
1. **阶段一**：设置 `SerialManager.js` 为只读状态
2. **创建备份**：`SerialManager.js.backup`
3. **详细分析**：现有API接口和功能
4. **制定计划**：详细的任务分解和时间安排

### 优先级顺序
1. **高优先级**：阶段一、二、三（核心协议和调度器）
2. **中优先级**：阶段四、五、六（基础架构和CLI）
3. **低优先级**：阶段七、八、九（WebUI、API、Sync）

### 风险缓解
- **时间缓冲**：预留20%的时间缓冲
- **并行开发**：核心模块可以并行开发
- **早期验证**：尽早进行功能对等验证

## 📝 记录要求

### 1. 进度记录
- **每日记录**：完成的任务和遇到的问题
- **问题记录**：技术问题和解决方案
- **决策记录**：重要的架构决策和理由

### 2. 测试记录
- **测试结果**：每个阶段的测试结果
- **性能数据**：性能测试的详细数据
- **问题跟踪**：发现的问题和修复状态

### 3. 文档更新
- **架构文档**：及时更新架构设计
- **API文档**：及时更新API接口文档
- **用户文档**：及时更新用户使用文档

---

**记住**：这是一个价值巨大的重构项目，必须谨慎实施，确保每个阶段都达到预期目标。功能对等是最高优先级，性能保持是基本要求，架构清晰是长期目标。# SerialBridge 重构工作指导规则

## 🎯 重构目标
将现有的1287行 `SerialManager.js` 重构为模块化的 `SerialBridge` 架构，彻底重写核心协议，设计统一、简洁、通用的数据传输协议。

## 🏗️ 核心设计原则

### 1. 统一协议设计
- **协议格式**：`[0xAA][TYPE][REQ_ID][LEN_H][LEN_L][DATA][CHECKSUM]`
- **无长度限制**：支持最大65535字节的单包传输
- **类型清晰**：通过TYPE字段明确区分数据类型
- **二进制安全**：支持任意二进制数据，包括换行符等特殊字符
- **统一处理**：所有数据使用相同的封包/解包逻辑

### 2. 分层架构设计
```
应用层 (业务逻辑) → 统一传输层 (SerialBridge) → 核心层 (协议处理) → 基础层 (基础服务)
```
- **职责分离**：每层职责清晰，边界清楚
- **调度器透明**：应用层调用`serialBridge.sendData()`，调度器自动工作
- **模块化**：每个模块控制在200-400行

### 3. 功能对等保证
- **功能一致性优先**：最终功能与重构前保持一致，而非API兼容性
- **服务重写**：上层服务可以完全重写，利用新核心的优势
- **独立测试**：核心功能独立测试，不依赖上层应用

## 📅 实施阶段指导

### 阶段一：现状调研与保护 (0.5天)
**必须完成**：
- [ ] 设置 `SerialManager.js` 为只读状态
- [ ] 创建 `SerialManager.js.backup` 备份文件
- [ ] 详细分析现有API接口和功能
- [ ] 分析现有配置结构和事件系统

**验收标准**：现有代码完全保护，现有功能完全理解

### 阶段二：统一协议设计 (1-2天)
**核心任务**：
- [ ] 实现 `ProtocolUtils` 统一协议工具
- [ ] 实现 `UnifiedProtocol` 统一协议处理器
- [ ] 支持任意字符传输（包括换行符）
- [ ] 编写协议兼容性测试用例

**验收标准**：统一协议格式确定，封包/解包逻辑正确

### 阶段三：传输调度器设计 (1-2天)
**核心任务**：
- [ ] 实现 `TransmissionScheduler` 内部调度器
- [ ] 设计服务注册和优先级机制
- [ ] 实现基本的调度逻辑
- [ ] 实现与核心层的接口对接

**验收标准**：调度器架构设计完成，基本调度功能实现

### 阶段四：基础架构搭建 (1-2天)
**核心任务**：
- [ ] 实现 `ConfigManager` 配置管理
- [ ] 实现 `ConnectionManager` 连接管理
- [ ] 实现 `SerialBridge` 统一传输层
- [ ] 创建适配器模式，保持现有功能可用

**验收标准**：新模块与现有模块并行存在，基础功能正常

### 阶段五：统一协议集成 (2-3天)
**核心任务**：
- [ ] 集成 `UnifiedProtocol` 到 `SerialBridge`
- [ ] 实现文本数据传输（支持换行符）
- [ ] 实现文件数据传输
- [ ] 实现配置热重载

**验收标准**：文本和文件传输正常，统一协议解析正确

### 阶段六：CLI服务重写 (1-2天)
**核心任务**：
- [ ] 重写 `FileTransferService` 文件传输服务
- [ ] 重新实现大数据自动处理
- [ ] 重新实现详细进度跟踪
- [ ] 重写CLI命令和交互逻辑

**验收标准**：CLI服务功能与重构前完全对等

## 🔧 技术实现指导

### 1. SerialBridge 统一传输层
```javascript
class SerialBridge extends EventEmitter {
  // 统一传输接口 (集成调度器，对应用层透明)
  async sendData(type, data, reqId, options)
  
  // 连接管理
  async connect(portOverride)
  async disconnect(isManual)
  getConnectionStatus()
  
  // 配置热重载
  async reloadConfig()
  updateConfig(newConfig)
}
```

**设计特点**：
- 集成调度器功能，自动管理所有传输任务
- 对应用层完全透明，无需显式调用调度器
- 提供与现有 `SerialManager` 完全相同的API

### 2. TransmissionScheduler 内部调度器
```javascript
class TransmissionScheduler {
  // 内部调度接口 (SerialBridge内部调用)
  async scheduleTransmission(task)
  
  // 队列管理
  enqueueTask(task)
  pauseTask(taskId)
  resumeTask(taskId)
  removeTask(taskId)
  clearQueue()
  
  // 队列状态
  getQueueStatus()
  getTaskStatus(taskId)
  getQueueStatistics()
}
```

**设计理念**：
- SerialBridge内部使用，应用层完全不可见
- 统一队列管理，智能调度
- 支持任务的暂停、恢复、剔除等操作

### 3. UnifiedProtocol 统一协议处理
```javascript
class UnifiedProtocol {
  // 统一封包/解包
  packData(type, reqId, data)
  unpackData(packet)
  
  // 数据类型处理 (支持任意字符)
  handleTextData(data)        // 支持换行符等特殊字符
  handleFileData(data)
  handleApiRequest(data)
  handleApiResponse(data)
  handleControlCommand(data)
  handleProgressData(data)    // 进度信息
  
  // 工具函数
  calculateChecksum(data)
  compressData(data)
  decompressData(data)
  isBinarySafe(data)
}
```

## 🛡️ 风险控制规则

### 1. 代码保护
- **必须设置**：`SerialManager.js` 为只读状态
- **必须创建**：备份文件 `SerialManager.js.backup`
- **禁止修改**：现有文件，只能作为参考

### 2. 功能对等验证
- **每个阶段**：必须通过功能对等测试
- **测试覆盖**：功能对等测试、回归测试、性能测试
- **验证标准**：相同输入产生相同功能结果

### 3. 渐进式替换
- **并行开发**：新模块与现有模块并行存在
- **配置开关**：控制使用新旧实现
- **逐步切换**：先切换非关键功能，再切换核心功能

## 📊 质量保证规则

### 1. 代码质量
- **模块大小**：每个核心模块控制在200-400行
- **职责单一**：每个模块只负责一个明确的功能
- **接口清晰**：提供简洁明确的API接口

### 2. 测试要求
- **单元测试**：每个模块必须有完整的单元测试
- **集成测试**：模块间协作必须有集成测试
- **性能测试**：确保不降低现有性能水平

### 3. 文档同步
- **代码注释**：关键逻辑必须有详细注释
- **API文档**：所有公共接口必须有文档
- **架构文档**：及时更新架构设计文档

## 🚫 禁止事项

### 1. 架构破坏
- **禁止**：在核心层实现业务逻辑
- **禁止**：应用层直接调用调度器
- **禁止**：破坏分层架构的边界

### 2. 兼容性破坏
- **禁止**：修改现有事件名称和参数
- **禁止**：破坏现有API接口
- **禁止**：降低现有功能性能

### 3. 代码质量
- **禁止**：创建超过400行的模块
- **禁止**：在核心层添加业务逻辑
- **禁止**：忽略错误处理和边界情况

## ✅ 成功标准

### 1. 功能标准
- [ ] 所有现有功能与重构前完全对等
- [ ] 新架构模块职责清晰
- [ ] 代码行数合理分布（每个模块<400行）
- [ ] 功能对等测试覆盖率达到80%以上

### 2. 性能标准
- [ ] 连接建立时间不超过现有水平
- [ ] 数据传输速度不低于现有水平
- [ ] 内存使用不超过现有水平
- [ ] CPU使用率不超过现有水平

### 3. 维护性标准
- [ ] 新功能开发效率提升50%
- [ ] 代码定位时间减少70%
- [ ] 单元测试编写时间减少60%
- [ ] 文档维护工作量减少40%

## 🎯 下一步行动

### 立即开始
1. **阶段一**：设置 `SerialManager.js` 为只读状态
2. **创建备份**：`SerialManager.js.backup`
3. **详细分析**：现有API接口和功能
4. **制定计划**：详细的任务分解和时间安排

### 优先级顺序
1. **高优先级**：阶段一、二、三（核心协议和调度器）
2. **中优先级**：阶段四、五、六（基础架构和CLI）
3. **低优先级**：阶段七、八、九（WebUI、API、Sync）

### 风险缓解
- **时间缓冲**：预留20%的时间缓冲
- **并行开发**：核心模块可以并行开发
- **早期验证**：尽早进行功能对等验证

## 📝 记录要求

### 1. 进度记录
- **每日记录**：完成的任务和遇到的问题
- **问题记录**：技术问题和解决方案
- **决策记录**：重要的架构决策和理由

### 2. 测试记录
- **测试结果**：每个阶段的测试结果
- **性能数据**：性能测试的详细数据
- **问题跟踪**：发现的问题和修复状态

### 3. 文档更新
- **架构文档**：及时更新架构设计
- **API文档**：及时更新API接口文档
- **用户文档**：及时更新用户使用文档

---

**记住**：这是一个价值巨大的重构项目，必须谨慎实施，确保每个阶段都达到预期目标。功能对等是最高优先级，性能保持是基本要求，架构清晰是长期目标。